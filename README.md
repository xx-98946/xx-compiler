# 简单的编译器

该项目的灵感来自[the-super-tiny-compiler.js](https://github.com/jamiebuilds/the-super-tiny-compiler)

## 编译器有哪些应用场景

编译器的作用是将代码的一种表示形式转换成另一种表示形式，编译器的功能是很强大的，让我们根据场景来说明不同的作用吧：

- `nodejs`：javascript 解释器，将 JavaScript 解释执行，目标就是机器码

- `svelte`： 框架，将 svelte 代码转变为 javascript 代码，更高的抽象
- `rollup`： 打包工具，将代码进行压缩和优化
- `babel`： 将 ES6 以上的代码转变为 ES5 的代码，以及 node 模块和 ES 模块的转换
- `corejs`： 浏览器中的 pollfills，将新功能转换为旧功能的实现，实际上是 babel 的核心
- `typescript`： 将 typescript 编译为 javascript
- `prettier`： 代码格式化，紧凑代码并使其具有一致的代码格式
- `sass`： 将 sass 代码转变为 css 代码
- `postcss`： 将 css 代码转变为兼容性更强的 chrome/firefox 等目标 css 代码

## 为什么需要了解编译器的基本工作原理

从前端视角，编译器主要在搭建开发环境方面起到了重要作用，目前前端的完整开发环境几乎包含了上面列举的场景中的全部，前端愉快的开发体验大多是基于这些开发工具来提供的，这让我们不再受兼容性的困扰，感谢这些奉献的开发者！！

但你仔细研究过前端工具链的工作原理，你会发现他们实际上包含大量的冗余工作，并且整个过程的效率是很低的，很多开发者意识到上面的这些工具实际上可以被整合起来,而且可以使用更高效的语言来完成这件事。

有很多开发者已经在做这件事情了，那就是 deno 和 rome 项目，两者都是 rust 开发的用于提供前端工具链的工具。

- `deno`： javascript 和 typescript 解释器，同时提供了大量的工具链工具，作者是 nodejs 的原作者

- `rome`： 一个 npm 包，目标是提供所有工具链功能，目前还在开发中，作者是 babel 的原作者

## 我们能用编译器做什么？

目前我在做一个低代码平台的项目，目标是根据 JSON 文件生成 Vue 目标代码。这个转换过程就是一个典型的编译过程，但如何完成这部分工作一直困扰着我。

另一个想做的事情和 webAssembly 相关，它一种高效的跨平台二进制格式。凭借于此，我们能做出更多的超出浏览器本身的事情，而且不受限于任何平台环境。如果 wasi 发展成熟，将能更有效地实现跨平台程序。

在写该文章的时候，发现 md 到 html 的转换过程也是一个编译器，而一个比较流行的 NPM 包是[marked](https://github.com/markedjs/marked)。

## 编译器的基本结构

典型的编译器一般分为三个部分：

1. 词义分析（tokenizer）: 将原始的代码拆分成功能独立的单词数组
2. 语义分析（parser)：将词义分析生成的单词数组处理为 AST
3. 代码生成（codeGeneretor）：根据 AST 生成目标代码

有些编译器会将语义分析和词义分析同时处理，这样可能就不存在对应的 tokens。

如果源代码和目标代码需要依赖于不同的 AST 结构，那么在语义分析和代码生成之间会会存在一个格式转换的结构

如果是为了更高的执行效率，需要对语义分析之后的 AST 进行优化之后，才进行代码生成，这样还会增一层 optimizer（优化器）

## 要实现的功能

本项目的目标是将 LISP 语言风格的代码转换为 C 语言风格的代码，当然只实现最基本的结构，具体功能如下表所示：

| 功能        | LISP              | C                 |
| ----------- | ----------------- | ----------------- |
| 2 + 2       | (add 2 2)         | add(2, 2)         |
| 4 - 2       | (sub 4 2)         | sub(4, 2)         |
| 2 + (4 - 2) | (add 2 (sub 4 2)) | add(2, sub(4, 2)) |
